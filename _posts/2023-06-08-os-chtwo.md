---
layout: post
title: Operating Systems Ch2 Introduction to Operating Systems
subtitle: Introduction to Operating Systems
categories: OS
tags: [OS]
---

# Ch 2: Introduction to Operating Systems

프로그램을 작동시키는 일은 쉬운일이다. 명령을 읽어서 해당하는 내용을 실행시키면 된다. 이것을 세분화 할 경우 **1. Fetch** **2. Decode** **3. Execute** 로 나눌 수 있다. 이때 프로그램이 원활히 작동할 수 있도록 돕는 것이 운영체제의 역할이다. 이를 수행하기 위해 운영체제는 **Virtualization** 이라는 가상화 단계를 거치게 된다. 가상화란 물리적인 자원을 사용하기 쉽도록 가상의 것을 만드는 것을 가상화라 한다. 따라서 운영체제는 때론 가상머신이라 불리기도 한다. 사용자와 이 과정이 원활히 이뤄질 수 있도록 운영체제는 API를 제공한다. 하나의 애플리케이션이 실행됨에 있어 운영체제는 수백개의 **System call** 을 호출하기도 한다. 운영체제는 다양한 분야에서 프로그램 실행에 도움을 주고 있기 때문에 **Standard Library** 라고 불리기 도 한다. 

가상화를 통해 얻을 수 있는 효용에는 먼저 많은 프로그램이 실행될 수 있게 한다. 그리고 동시에 명령과 데이터에 접근할 수 있게 해준다 (Mem Sharing). 프로그램들이 다른 기기에 접근할 수 있게 도와준다. 가장 중요한 점은 자원의 효율적인 배분이다 (**Resource Manager**). CPU, memory 와 같은 자원을 효율적으로 할당해주어 프로그램이 작동할 수 있게 해주는 것이다.       

<br>




## 2.1: Visualizing the CPU

우리가 작성한 프로그램에는 Spin이라는 함수가 있는데 이것이 하는 일은 시간을 체크해서 1초가 지날때마다 리턴되는 것이다. 그 이후에는 유저의 입력을 받아서 해당 내용을 무한 반복하며 출력한다. 똑같은 코드를 여러개 실행하면 어떻게 될까? 우리는 <span style="text-decoration:underline;">하나의 프로세서를 갖고 있음에도 여러 개의 프로세서가 있는 것 처럼 4개의 프로그램이 동시에 작동된다</span>. 이것은 환상의 일종인데 운영체제가 하나의 물리적인 CPU를 가상화해서 여려개로 나눴기 때문에 가능한 것이다. 이것이** Virtualizing CPU. **흥미로운 질문이 떠오르는데 만약 동시에 두개의 프로그램이 실행되고 싶다면 어느 것을 골라야 할까? 해당 질문에 답은 **Policy **로 귀결 될 수 있다. 추후에 **Mechanism** 과 같이 나오게 될 개념이다.

<br>

## 2.2: Virtualizing Memory

현대 시대의 물리적 메모리는 바이트들의 배열로 이뤄져 있다. 이를 읽고 쓰기 위해선 데이터의 위치를 기억하는 주소값이 필요하다. 앞서 언급한 것 처럼 프로그램을 작동시켜 위해선 끊임 없는 명령을 읽어와야 하는데 이때 명령 값 또한 메모리에 저장된다. 따라서 메모리에 접근하는 것은 필수적인 사항이다. 하나의 프로그램에 여러개의 객체를 실행시키고 메모리 주소의 변동사항을 확인했다. 예상대로라면 값이 다른 것이 맞으나 실행결과 동일한 주소 값을 지닌채로 각자의 일을 수행하고 있었다. 각자의 일을 수행하고 있는 것을 보면 개인의 메모리 값을 가지고 있는 것 처럼 보이나 이 역시도 착시현상이다. 개인의 물리적 주소가 아닌 **Virtual address space**를 가지고 있는 것이다. 운영체제는 이를 물리적 주소와 연결하여 프로그램들을 작동한다.  
<br>


## 2.3: Concurrency

동시성 (Concurrency) 또한 중요한 개념이다. 위에서 확인한대로 운영체제는 여러가지 프로그램을 동시에 돌리고 있다. 이와 같은 문제는 **multi-threaded program**에서도 확인이 된다. 이를 확인하기 위해 우리는 두개의 쓰래드를 실행했고 100000까지 숫자를 증가하게 했다. 예상대로라면 200000이 결과가 되어야 하지만 그에 한참 못 미치는 140000이 결과가 되었다. 이는 명령이 실행되는 방식의 차이로 인한 것이다. 우리 눈에는 동시에 두개의 쓰레드가 동작하고 있는 것 처럼 보이나 실상은 하나씩 순서를 번갈아 가며 실행하고 있는 것이다. 따라서 동시에 프로그램이 돌아가는 것은 아니다. 우리는 이러한 문제를 **problem of concurrency** 라고 부른다  
<br>


## 2.4: Persistence

세번째 중요한 개념은 **Persistence**이다. Ram은 휘발성 메모리이기 때문에 정보가 쉽게 사라질 수 있다. 따라서 나머지 HW에서 지속적으로 정보를 저장해야한다. 이 HW는 우리가 흔히들 부르는 I/O Device인데 예시로 하드디스크와 SSD가 존재한다. OS 내부에서 디스크를 관리하는 system을 **file system** 이라고 한다. 위 예시들과는 달리 디스크에 대해 따로 OS가 가상화를 진행하지는 않는다. 이는 사용자가 파일을 공유하고 싶다는 생각에서 착안했다. 우리가 흔히들 파일을 작성하는데 사용하는 system call인 write() open() 과 같은 것은 file system의 일부이다.  

<br>
<br>

## 2.5: Design Goals



1. Take physical resources(CPU, Mem) and **virtualize** them.
2. Deal with the problem of **concurrency.**
3. Store files **persistently.**

이 모든 것을 이뤘을 때의 최종 목표는 **Abstraction** 이다. 추상화란 복잡한 자료 모듈 시스템 등으로 부터 핵심 기능을 간추려 내는 것을 말한다. 추상화를 통해 거대한 프로그램을 작성할 때 작은 것으로 조각내어 진행할 수 있다. 우리가 C를 작성할 때 기계어를 고려하지 않는 것 처럼 그 편의성은 방대하다. 또다른 목표는 **High** **Performance** 다른 말로 **Minimizing overhead.** 오버헤드는 시간에 증가, 메모리의 증가와 같은 다양한 문제를 야기한다. 마지막 목표는 **Protection.** 다른 프로그램이 OS에 영향을 끼치지 않도록 보호하는 것이 OS의 목표이다.


